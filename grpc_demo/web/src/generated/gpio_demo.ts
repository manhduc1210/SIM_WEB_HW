// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "gpio_demo.proto" (package "simgpio", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Message rỗng dùng cho RPC không cần tham số.
 *
 * @generated from protobuf message simgpio.Empty
 */
export interface Empty {
}
/**
 * ======================= Requests =======================
 *
 * @generated from protobuf message simgpio.ButtonReq
 */
export interface ButtonReq {
    /**
     * Chỉ số nút: 0 hoặc 1 (mặc định demo có 2 nút BTN0/BTN1).
     * Server nên trả STATUS_INVALID_ARG nếu ngoài phạm vi.
     *
     * @generated from protobuf field: int32 index = 1
     */
    index: number;
}
/**
 * @generated from protobuf message simgpio.ConfigureReq
 */
export interface ConfigureReq {
    /**
     * Số lượng LED trong mô phỏng (ví dụ: 4). Nếu <=0, server có thể trả STATUS_INVALID_ARG.
     *
     * @generated from protobuf field: int32 led_count = 1
     */
    ledCount: number;
    /**
     * Nếu true: logic 1 → LED tắt (active-low). Nếu false: logic 1 → LED sáng (active-high).
     *
     * @generated from protobuf field: bool leds_active_low = 2
     */
    ledsActiveLow: boolean;
    /**
     * Giá trị khởi tạo cho toàn bộ LED sau cấu hình (0/1). Server có thể chuẩn hoá về {0,1}.
     *
     * @generated from protobuf field: int32 initial_value = 3
     */
    initialValue: number;
    /**
     * (Tuỳ chọn) Reset luôn trạng thái nút/đếm về mặc định sau khi cấu hình.
     *
     * @generated from protobuf field: bool reset_after = 4
     */
    resetAfter: boolean;
}
/**
 * ======================= Responses =======================
 *
 * @generated from protobuf message simgpio.LedState
 */
export interface LedState {
    /**
     * Trạng thái từng LED theo thứ tự LSB..MSB. Mặc định 0/1.
     * Nếu bạn chắc chắn chỉ 0/1, có thể chuyển sang repeated bool trong tương lai.
     *
     * @generated from protobuf field: repeated int32 leds = 1
     */
    leds: number[];
}
/**
 * @generated from protobuf message simgpio.SimpleReply
 */
export interface SimpleReply {
    /**
     * Thông điệp người đọc (giữ #1 để tương thích ngược).
     *
     * @generated from protobuf field: string msg = 1
     */
    msg: string;
    /**
     * Mã trạng thái máy đọc (mới thêm, #2 để không phá cũ).
     *
     * @generated from protobuf field: simgpio.Status status = 2
     */
    status: Status;
}
/**
 * ======================= Status & Common =======================
 * Enum trạng thái chuẩn hoá để máy móc bắt lỗi dễ hơn.
 * 0 là giá trị mặc định theo khuyến nghị protobuf.
 *
 * @generated from protobuf enum simgpio.Status
 */
export enum Status {
    /**
     * @generated from protobuf enum value: STATUS_OK = 0;
     */
    OK = 0,
    /**
     * tham số không hợp lệ (vd: index ngoài phạm vi)
     *
     * @generated from protobuf enum value: STATUS_INVALID_ARG = 1;
     */
    INVALID_ARG = 1,
    /**
     * lỗi khác khi xử lý
     *
     * @generated from protobuf enum value: STATUS_FAILED = 2;
     */
    FAILED = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("simgpio.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message simgpio.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ButtonReq$Type extends MessageType<ButtonReq> {
    constructor() {
        super("simgpio.ButtonReq", [
            { no: 1, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ButtonReq>): ButtonReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        if (value !== undefined)
            reflectionMergePartial<ButtonReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ButtonReq): ButtonReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 index */ 1:
                    message.index = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ButtonReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).int32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message simgpio.ButtonReq
 */
export const ButtonReq = new ButtonReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigureReq$Type extends MessageType<ConfigureReq> {
    constructor() {
        super("simgpio.ConfigureReq", [
            { no: 1, name: "led_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leds_active_low", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "initial_value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "reset_after", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigureReq>): ConfigureReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ledCount = 0;
        message.ledsActiveLow = false;
        message.initialValue = 0;
        message.resetAfter = false;
        if (value !== undefined)
            reflectionMergePartial<ConfigureReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigureReq): ConfigureReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 led_count */ 1:
                    message.ledCount = reader.int32();
                    break;
                case /* bool leds_active_low */ 2:
                    message.ledsActiveLow = reader.bool();
                    break;
                case /* int32 initial_value */ 3:
                    message.initialValue = reader.int32();
                    break;
                case /* bool reset_after */ 4:
                    message.resetAfter = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigureReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 led_count = 1; */
        if (message.ledCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.ledCount);
        /* bool leds_active_low = 2; */
        if (message.ledsActiveLow !== false)
            writer.tag(2, WireType.Varint).bool(message.ledsActiveLow);
        /* int32 initial_value = 3; */
        if (message.initialValue !== 0)
            writer.tag(3, WireType.Varint).int32(message.initialValue);
        /* bool reset_after = 4; */
        if (message.resetAfter !== false)
            writer.tag(4, WireType.Varint).bool(message.resetAfter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message simgpio.ConfigureReq
 */
export const ConfigureReq = new ConfigureReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LedState$Type extends MessageType<LedState> {
    constructor() {
        super("simgpio.LedState", [
            { no: 1, name: "leds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LedState>): LedState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.leds = [];
        if (value !== undefined)
            reflectionMergePartial<LedState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LedState): LedState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 leds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.leds.push(reader.int32());
                    else
                        message.leds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LedState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 leds = 1; */
        if (message.leds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.leds.length; i++)
                writer.int32(message.leds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message simgpio.LedState
 */
export const LedState = new LedState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleReply$Type extends MessageType<SimpleReply> {
    constructor() {
        super("simgpio.SimpleReply", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["simgpio.Status", Status, "STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<SimpleReply>): SimpleReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msg = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<SimpleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleReply): SimpleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* simgpio.Status status */ 2:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* simgpio.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message simgpio.SimpleReply
 */
export const SimpleReply = new SimpleReply$Type();
/**
 * @generated ServiceType for protobuf service simgpio.GpioDemo
 */
export const GpioDemo = new ServiceType("simgpio.GpioDemo", [
    { name: "PressButton", options: {}, I: ButtonReq, O: SimpleReply },
    { name: "ReleaseButton", options: {}, I: ButtonReq, O: SimpleReply },
    { name: "GetLedState", options: {}, I: Empty, O: LedState },
    { name: "Reset", options: {}, I: Empty, O: SimpleReply },
    { name: "Configure", options: {}, I: ConfigureReq, O: SimpleReply },
    { name: "EventStream", serverStreaming: true, options: {}, I: Empty, O: LedState }
]);
